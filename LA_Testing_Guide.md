# 邏輯分析儀 (LA) 測試指南

## 📊 連接設定

### 🔌 硬體連接

```
Arduino UNO          邏輯分析儀 (LA)         aRGB LED
┌─────────────┐     ┌─────────────┐        ┌─────────┐
│             │     │             │        │         │
│   Pin 11    ├─────┤ CH0 (DATA)  ├────────┤ DIN     │
│   (MOSI)    │     │             │        │         │
│             │     │             │        │         │
│   Pin 13    ├─────┤ CH1 (CLK)   │        │         │
│   (SCK)     │     │             │        │         │
│             │     │             │        │         │
│    GND      ├─────┤ GND         ├────────┤ GND     │
│             │     │             │        │         │
│     5V      ├─────────────────────────────┤ VCC     │
│             │     │             │        │         │
└─────────────┘     └─────────────┘        └─────────┘

重要提醒:
✅ CH0 (DATA) 是最重要的訊號
✅ CH1 (CLK) 用於時序參考
✅ 不需要連接 CS/SS (Pin 10)
✅ 確保共同接地
```

### ⚙️ LA 設定參數

| 參數 | 建議值 | 說明 |
|------|--------|------|
| 採樣率 | ≥25MHz | SPI頻率(3.3MHz)的8倍以上 |
| 觸發模式 | CH0 上升沿 | 數據開始傳輸時觸發 |
| 記錄長度 | ≥100μs | 包含完整的24位+Latch Time |
| 通道設定 | CH0:DATA, CH1:CLK | 雙通道同步記錄 |

## 🎯 測試程式使用

### 使用 `la_test_version.ino`

這個專門的測試版本提供：

1. **已知位元模式測試** - 驗證編碼邏輯
2. **單一顏色測試** - 驗證RGB傳輸
3. **完整數據測試** - 驗證24位傳輸
4. **連續發送測試** - 驗證時序間隔

### 🚀 開始測試

1. 上傳 `la_test_version.ino` 到 Arduino
2. 開啟串列監視器 (115200 baud)
3. 連接 LA 探棒
4. 設定 LA 參數
5. 按任意鍵開始測試

## 📈 預期波形分析

### Logic 0 和 Logic 1 識別

```
Logic 0 (SPI: 1000):
     ▄▄▄▄            
    ▄    ▄▄▄▄▄▄▄▄▄▄▄
   約300ns  約900ns

Logic 1 (SPI: 1110):
     ▄▄▄▄▄▄▄▄▄▄      
    ▄           ▄▄▄▄▄
   約900ns    約300ns
```

### 8位到32位編碼範例

原始數據: `0xAA` (10101010)
編碼結果: `0xE8E8E8E8`

```
原始位元:  1  0  1  0  1  0  1  0
SPI編碼: 1110 1000 1110 1000 1110 1000 1110 1000
十六進位:  E   8   E   8   E   8   E   8
```

### 完整RGB傳輸時序

```
時間軸: 0    24   48   72   96  μs
       │    │    │    │    │
       R    G    B    Latch
      (8bit)(8bit)(8bit)(>50μs)
      
每個顏色: 8bit × 4 SPI bits = 32 SPI bits
每 SPI bit: 約300ns
每顏色時間: 約9.6μs
```

## 🔍 驗證檢查點

### ✅ 基本連接驗證

1. **DATA線有訊號** - CH0應該看到SPI傳輸
2. **CLK線有時鐘** - CH1應該看到3.3MHz時鐘
3. **時序同步** - DATA變化應該與CLK邊沿對齊

### ✅ 編碼邏輯驗證

測試 `0x00` (00000000):
- 預期: 8個 `1000` 模式
- LA應顯示: `0x88888888`

測試 `0xFF` (11111111):
- 預期: 8個 `1110` 模式  
- LA應顯示: `0xEEEEEEEE`

測試 `0xAA` (10101010):
- 預期: 交替 `1110 1000` 模式
- LA應顯示: `0xE8E8E8E8`

### ✅ RGB順序驗證

設定 R=0x80, G=0x40, B=0x20 時：
1. 前32位應該是R的編碼
2. 中32位應該是G的編碼  
3. 後32位應該是B的編碼
4. 最後是>50μs的低電平

### ✅ Latch Time驗證

- 在96位RGB數據後
- 應該有>50μs的持續低電平
- 程式設定為60μs

## 🐛 常見問題診斷

### 問題1: 沒有訊號

**可能原因:**
- LA探棒沒有正確連接
- Arduino程式沒有執行
- SPI沒有正確初始化

**檢查方法:**
- 確認探棒連接到Pin 11和Pin 13
- 檢查串列監視器輸出
- 驗證Arduino電源正常

### 問題2: 時序不正確

**可能原因:**
- LA採樣率太低
- 觸發設定錯誤
- 時基設定不當

**解決方法:**
- 提高採樣率到25MHz以上
- 使用CH0上升沿觸發
- 調整時基顯示完整波形

### 問題3: 編碼錯誤

**可能原因:**
- SPI模式設定錯誤
- 位元順序錯誤
- 編碼邏輯錯誤

**檢查方法:**
- 確認使用SPI_MODE0
- 確認使用MSBFIRST
- 對照已知模式測試結果

## 📋 測試記錄表

| 測試項目 | 輸入值 | 預期編碼 | LA測量值 | 結果 |
|----------|--------|----------|----------|------|
| 0x00 | 00000000 | 0x88888888 | ________ | ☐ |
| 0xFF | 11111111 | 0xEEEEEEEE | ________ | ☐ |
| 0xAA | 10101010 | 0xE8E8E8E8 | ________ | ☐ |
| 0x55 | 01010101 | 0x8E8E8E8E | ________ | ☐ |
| RGB完整 | R,G,B | 96位+Latch | ________ | ☐ |

## 🎓 進階分析

### 計算驗證

對於任意8位值，可以手動計算32位編碼：

```python
def encode_byte(value):
    result = 0
    for i in range(8):
        bit = (value >> (7-i)) & 1
        if bit:
            result = (result << 4) | 0xE  # 1110
        else:
            result = (result << 4) | 0x8  # 1000
    return result

# 範例
print(hex(encode_byte(0xAA)))  # 應該輸出: 0xe8e8e8e8
```

### 時序計算

- SPI頻率: 3.3MHz → 週期約303ns
- 每個邏輯位元: 4個SPI位元 → 約1.21μs
- 每個顏色: 8個邏輯位元 → 約9.68μs  
- 完整RGB: 24個邏輯位元 → 約29μs
- 加上Latch: 總計約89μs

使用這個指南，你就可以準確地驗證aRGB LED的SPI控制訊號了！
