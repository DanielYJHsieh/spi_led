# aRGB LED 數據結構與傳輸說明

## 🔍 aRGB LED 硬體架構

### 單顆 aRGB LED 內部結構

```
       單顆 aRGB LED (如 WS2812B)
    ┌─────────────────────────────────┐
    │  ┌─────┐  ┌─────┐  ┌─────┐     │
    │  │ RED │  │GREEN│  │BLUE │     │
    │  │ LED │  │ LED │  │ LED │     │
    │  └─────┘  └─────┘  └─────┘     │
    │     ↑        ↑        ↑        │
    │  8-bit    8-bit    8-bit       │
    │ R_reg     G_reg    B_reg       │
    │     ↑        ↑        ↑        │
    │  ┌─────────────────────────┐   │
    │  │     控制IC (內建)        │   │
    │  │   - 接收24位數據         │   │
    │  │   - 解碼RGB控制訊號      │   │
    │  │   - PWM驅動LED          │   │
    │  └─────────────────────────┘   │
    │           ↑                    │
    │         DIN                    │
    └─────────────────────────────────┘
```

### 數據結構映射

根據 Everstars 文檔：

```cpp
// 單顆 aRGB LED 的數據結構
struct LED {
    uint8_t R_reg;  // 紅色暫存器 (0-255)
    uint8_t G_reg;  // 綠色暫存器 (0-255)  
    uint8_t B_reg;  // 藍色暫存器 (0-255)
};

// 多顆 aRGB LED 陣列
LED Display[3] = {
    {0xFF, 0x00, 0x00},  // LED1: 紅色
    {0x00, 0xFF, 0x00},  // LED2: 綠色
    {0x00, 0x00, 0xFF}   // LED3: 藍色
};
```

## 📊 數據傳輸流程

### Step 1: 原始數據準備

```
aRGB LED #1: R=0xFF, G=0x00, B=0x00 (紅色)
aRGB LED #2: R=0x00, G=0xFF, B=0x00 (綠色)  
aRGB LED #3: R=0x00, G=0x00, B=0xFF (藍色)
```

### Step 2: 8位到32位編碼轉換

每個8位顏色值轉換為32位SPI數據：

```
原始8位:  1 1 1 1 1 1 1 1  (0xFF)
SPI編碼: 1110 1110 1110 1110 1110 1110 1110 1110
32位結果: 0xEEEEEEEE

原始8位:  0 0 0 0 0 0 0 0  (0x00)  
SPI編碼: 1000 1000 1000 1000 1000 1000 1000 1000
32位結果: 0x88888888
```

### Step 3: 發送順序

```
時間軸: →→→→→→→→→→→→→→→→→→→→→→→→→→→→→→→→→→→→

發送順序:
LED1_R(32bit) → LED1_G(32bit) → LED1_B(32bit) →
LED2_R(32bit) → LED2_G(32bit) → LED2_B(32bit) →  
LED3_R(32bit) → LED3_G(32bit) → LED3_B(32bit) →
Latch(>50μs)

實際數據:
0xEEEEEEEE → 0x88888888 → 0x88888888 →  (LED1: 紅色)
0x88888888 → 0xEEEEEEEE → 0x88888888 →  (LED2: 綠色)
0x88888888 → 0x88888888 → 0xEEEEEEEE →  (LED3: 藍色)
>50μs 低電平                           (Latch Time)
```

## 🎯 關鍵概念澄清

### ❓ 常見誤解
- **錯誤理解**: 以為需要控制9個獨立的LED (3×3)
- **正確理解**: 控制3顆aRGB LED，每顆內建R+G+B三個發光元件

### ✅ 正確概念

1. **硬體層面**:
   - 3顆物理aRGB LED
   - 每顆LED內建3個發光元件 (R+G+B)
   - 每顆LED有一個控制IC

2. **軟體層面**:
   - 3個LED結構體
   - 每個結構體包含3個8位暫存器
   - 總共需要傳輸 3×24=72 位原始數據

3. **傳輸層面**:
   - 72位原始數據編碼為 3×3×32=288 位SPI數據
   - 加上Latch Time完成一次完整傳輸

## 🔬 邏輯分析儀觀察重點

在LA上你應該看到：

```
CH0 (DATA): 
┌─完整傳輸週期─┐
│ 288位SPI數據 │ >50μs低電平
└──────────────┘

時序分解:
- LED1_R: 32位 (約9.6μs)
- LED1_G: 32位 (約9.6μs)  
- LED1_B: 32位 (約9.6μs)
- LED2_R: 32位 (約9.6μs)
- LED2_G: 32位 (約9.6μs)
- LED2_B: 32位 (約9.6μs)
- LED3_R: 32位 (約9.6μs)
- LED3_G: 32位 (約9.6μs)
- LED3_B: 32位 (約9.6μs)
- Latch:  >50μs
總時間: 約137μs
```

## 💡 實際應用範例

### 彩色混合範例

```cpp
// 創建橙色 (紅+綠混合)
Display[0].R_reg = 0xFF;  // 紅色全亮
Display[0].G_reg = 0x80;  // 綠色半亮  
Display[0].B_reg = 0x00;  // 藍色關閉

// 創建紫色 (紅+藍混合)
Display[1].R_reg = 0x80;  // 紅色半亮
Display[1].G_reg = 0x00;  // 綠色關閉
Display[1].B_reg = 0xFF;  // 藍色全亮

// 創建白色 (三色全亮)
Display[2].R_reg = 0xFF;  // 紅色全亮
Display[2].G_reg = 0xFF;  // 綠色全亮
Display[2].B_reg = 0xFF;  // 藍色全亮
```

這樣就能在3顆aRGB LED上顯示橙色、紫色和白色！
